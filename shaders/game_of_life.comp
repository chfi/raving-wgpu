#version 450

#define WORKGROUP_SIZE_X 8
#define WORKGROUP_SIZE_Y 8
#define WORKGROUP_SIZE_Z 1

// one thread per cell across the entire dense board
layout(local_size_x = WORKGROUP_SIZE_X, 
       local_size_y = WORKGROUP_SIZE_Y, 
       local_size_z = WORKGROUP_SIZE_Z) in;

layout(set = 0, binding = 0) buffer WorldCfg {
    uint columns;
    uint rows;
    
    uvec2 viewport_size;

    vec2 view_offset;
    float scale;
    float _pad;
} config;

layout(set = 1, binding = 0) readonly buffer SrcWorld {
    uint blocks[];
} src;

layout(set = 1, binding = 1) buffer DstWorld {
    uint blocks[];
} dst;

#define BLOCK_COLUMNS 8
#define BLOCK_ROWS 4

uint block_index_for_cell(uvec2 cell) {
    uint block_cols = config.columns / BLOCK_COLUMNS;
    uvec2 blk = uvec2(cell.x / BLOCK_COLUMNS, cell.y / BLOCK_ROWS);
    return blk.x + blk.y * block_cols;
}

bool get_alive_in_block(uint block, uint col, uint row) {
    uvec2 loc = uvec2(col % BLOCK_COLUMNS, row % BLOCK_ROWS);
    uint loc_i = loc.x + loc.y * BLOCK_COLUMNS;
    bool cell_alive = ((block >> loc_i) & 1) == 1;
    return cell_alive;
}

void set_alive_in_block(out uint block, uint col, uint row) {
    uvec2 loc = uvec2(col % BLOCK_COLUMNS, row % BLOCK_ROWS);
    uint loc_i = loc.x + loc.y * BLOCK_COLUMNS;
    block |= (1 << loc_i);
}

// shared 

void main() {
    uvec2 cell = gl_GlobalInvocationID.xy;

    if (cell.x >= config.columns || cell.y >= config.rows) {
        return;
    }

    uint blk_index = block_index_for_cell(cell);
    // clear destination blocks

    if (cell.x % 8 == 0 && cell.y % 4 == 0) {
        dst.blocks[blk_index] = 0;
    }

    // groupMemoryBarrier();
    // memoryBarrierShared();
    // memoryBarrierBuffer();

    // bool alive = (cell.x + cell.y) % 11 == 0;

    
    // uvec2 pixel = gl_GlobalInvocationID.xy;
    // uvec2 out_size = imageSize(image);

    // vec4 base = vec4(v_tex_coords.x, 1.0, v_tex_coords.y, 1.0);
    // vec4 color = vec4
    // f_color = frag_inputs.color;
    // f_color = base;
}